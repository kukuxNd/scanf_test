## 使用说明

### 1. 函数原型
```c
int my_sscanf(const char *input, const char *format, ...);
```

### 2. 参数
- **`input`**  
  要解析的输入字符串。
- **`format`**  
  格式字符串，包含格式说明符和普通字符，用于指导解析过程。
- **`...`**  
  可变参数列表，用于存储解析结果。

### 3. 返回值
- 返回成功解析并赋值的参数数量（不包括 `%n`）。
- 如果解析过程中遇到错误（例如格式不匹配），返回当前已成功解析的参数数量。

### 4. 支持的格式说明符
| 说明符       | 描述                              | 示例输入       | 存储类型          |
|--------------|-----------------------------------|----------------|-------------------|
| `%d`, `%i`  | 有符号十进制整数                 | `123`          | `int`, `short`, `long` |
| `%u`         | 无符号十进制整数                 | `123`          | `unsigned int`, `unsigned long` |
| `%f`, `%e`, `%g` | 浮点数（包括科学计数法）     | `3.14`, `1e-2` | `float`, `double` |
| `%s`         | 字符串（需提供缓冲区大小）       | `hello`        | `char *`          |
| `%c`         | 单个字符                         | `a`            | `char *`          |
| `%x`, `%X`  | 十六进制整数                     | `1a`, `0x1A`  | `unsigned int`, `unsigned long` |
| `%o`         | 八进制整数                       | `077`          | `unsigned int`, `unsigned long` |
| `%p`         | 指针地址（十六进制）             | `0xdeadbeef`   | `void *`          |
| `%[a-z]`     | 扫描集（匹配指定字符集）         | `abc`          | `char *`          |
| `%[^a-z]`    | 反向扫描集（匹配非指定字符集）   | `123`          | `char *`          |
| `%n`         | 记录已读取的字符数               | -              | `int *`           |
| `%%`         | 匹配字面量 `%`                   | `%`            | 无                |

### 5. 修饰符
| 修饰符 | 描述               | 示例     | 适用说明符          |
|--------|--------------------|----------|---------------------|
| `h`    | 短整型            | `%hd`    | `%d`, `%i`, `%u`   |
| `l`    | 长整型或双精度    | `%ld`, `%lf` | `%d`, `%i`, `%u`, `%x`, `%o`, `%f` |
| `*`    | 跳过赋值          | `%*d`    | 所有说明符          |

### 6. 字段宽度和精度
- **字段宽度**：限制读取的最大字符数，例如 `%5s`（读取最多5个字符的字符串）。
- **精度**：控制浮点数的精度或字符串长度，例如 `%6.2f`（总宽度6，小数点后2位）。
- **动态精度**：使用 `*` 读取精度值，例如 `%.*f`（精度从参数列表中获取）。

### 7. 扫描集
- `%[a-z]`：匹配小写字母 `a` 到 `z`。
- `%[^0-9]`：匹配非数字字符。
- 支持范围（例如 `%[a-zA-Z]`）和反转（例如 `%[^a-z]`）。
- 支持字段宽度，例如 `%5[a-z]`。

### 8. 示例
#### 示例 1：基本用法
```c
const char *input = "123 3.14 abcDEF 0x1A 077";
int d;
float f;
char str[10];
int x, o;

int result = my_sscanf(input, "%d %f %[a-zA-Z] %x %o",
                       &d, &f, str, sizeof(str), &x, &o);
printf("Parsed items: %d\n", result); // 输出 5
printf("d: %d\n", d);                 // 输出 123
printf("f: %.2f\n", f);               // 输出 3.14
printf("str: %s\n", str);             // 输出 abcDEF
printf("x: %x\n", x);                 // 输出 1a
printf("o: %o\n", o);                 // 输出 77
```

#### 示例 2：带修饰符和扫描集
```c
const char *input = "0xdeadbeef 12.34e-2 hello";
void *p;
double f;
char str[10];

int result = my_sscanf(input, "%p %lf %5[a-z]",
                       &p, &f, str, sizeof(str));
printf("Parsed items: %d\n", result); // 输出 3
printf("p: %p\n", p);                 // 输出 0xdeadbeef
printf("f: %.4f\n", f);               // 输出 0.1234
printf("str: %s\n", str);             // 输出 hello
```

#### 示例 3：动态精度和跳过赋值
```c
const char *input = "123 456.789";
int d;
float f;

int result = my_sscanf(input, "%d %*d %.*f",
                       &d, 2, &f);
printf("Parsed items: %d\n", result); // 输出 2
printf("d: %d\n", d);                 // 输出 123
printf("f: %.2f\n", f);               // 输出 456.79
```

### 9. 注意事项
- **缓冲区大小**：对于 `%s` 和 `%[]`，必须提供缓冲区大小（`size_t` 类型）作为额外参数，避免溢出。
- **错误处理**：当前实现未显式返回错误码，但可通过返回值与预期解析数量比较来检测问题。
- **空白字符**：格式字符串中的空格会跳过输入中的任意数量空白字符。

### 10. 扩展潜力
- 可进一步添加对 `%a`（十六进制浮点数）或自定义格式的支持。
- 通过全局变量（如 `errno`）提供详细错误信息。

---

以上是对 `my_sscanf` 函数的进一步扩展及完整使用说明。新版本在功能性和灵活性上有了显著提升，能够满足更广泛的应用需求。